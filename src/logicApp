#include <Arduino.h>

byte segmentBits[11] = {
    0b00111111,
    0b00000110,
    0b01011011,
    0b01001111,
    0b01100110,
    0b01101101,
    0b01111101,
    0b00000111,
    0b01111111,
    0b01101111,
    0b00000000};

const uint8_t displayPins[7] = {2, 3, 4, 5, 6, 7, 8};

// turn off the display
const uint8_t BLANK = 10;

const uint8_t joySW = 11;
const uint8_t joyX = A0;
const uint8_t joyY = A1;

const uint8_t buzzerPin = 10;
const uint8_t ledPin = 9;

struct Level {
  const uint16_t speed;
  const uint8_t length;
};

Level levels[5] = {
    {5000, 10},
    {4000, 10},
    {3000, 15},
    {1000, 30},
    {500, 50}};

const uint8_t lvlsLength = sizeof(levels) / sizeof(levels[0]);
uint8_t currentLvl = 0;

uint8_t lvlCounter = 1;
bool isLevelMode = false;

bool isDirectionCorrect = false;
bool yMoved = false;

void displayDigit(int digit) {
  int segmentBit = segmentBits[digit];
  for (int i = 0; i < 7; i++) {
    digitalWrite(displayPins[i], (segmentBit >> i) & 1);
  }
}

void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(A5));

  for (int pin : displayPins) {
    pinMode(pin, OUTPUT);
    digitalWrite(pin, LOW);
  }

  pinMode(joySW, INPUT_PULLUP);
  pinMode(buzzerPin, OUTPUT);
  pinMode(ledPin, OUTPUT);
  digitalWrite(buzzerPin, LOW);

  displayDigit(1);
}

void pulsePin(uint8_t pin, uint16_t time) {
  digitalWrite(pin, HIGH);
  delay(time);
  digitalWrite(pin, LOW);
}

// setting a random segment
int drawSegment(int maxValue) {
  int segmentNumber = random(maxValue);

  // turing off all segments
  for (int pin : displayPins) {
    digitalWrite(pin, LOW);
  }

// checking segments to set the radnom segment
  switch (segmentNumber) {
    // top
    case 0:
      digitalWrite(displayPins[0], HIGH);
      break;
    // bottom
    case 1:
      digitalWrite(displayPins[3], HIGH);
      break;
    // right
    case 2:
      digitalWrite(displayPins[1], HIGH);
      digitalWrite(displayPins[2], HIGH);
      break;
    case 3:
    // left
      digitalWrite(displayPins[4], HIGH);
      digitalWrite(displayPins[5], HIGH);
      break;
  }

  return segmentNumber;
}

// checking the joystick to get the joystick direction 
bool handleJoystick(int xValue, int yValue, int value) {
  int joyValue;
  int dx = xValue - 512;
  int dy = yValue - 512;

  // absolute value
  int absDx = abs(dx);
  int absDy = abs(dy);

  // dead zone
  if (absDx < 100 && absDy < 100) {
    return false;
  }

  // checking x value 
  if (absDx > absDy) {
    joyValue = (dx > 0) ? 1 : 0;
  // checking y value
  } else {
    joyValue = (dy < 0) ? 2 : 3;
  }

  return joyValue == value;
}

// checking is player win
void checkScore(bool checkingValue) {
  if (checkingValue) {
    Serial.println("TRUE WIN");
    pulsePin(ledPin, 500);
  } else {
    Serial.println("FALSE LOSE");
    pulsePin(buzzerPin, 125);
    delay(375);
  }
}

// it allows you to choose the number of level
void chooseLevel(int valueY) {
  displayDigit(lvlCounter);

  // checking the direction
  if (valueY > 600) {
    // left
    lvlCounter--;
    pulsePin(buzzerPin, 100);
  } else if (valueY < 400) {
    // right
    lvlCounter++;
    pulsePin(buzzerPin, 100);
  }

  // reset number if it reached the limit
  if (lvlCounter > lvlsLength) {
    lvlCounter = 1;
  } else if (lvlCounter < 1) {
    lvlCounter = lvlsLength;
  }

  displayDigit(lvlCounter);
  delay(100);
}

// it alows you to stop or start the level
void switchLevel() {

  // listening the button
  if (digitalRead(joySW) == LOW) {

    // reset the parametrs
    displayDigit(lvlCounter);
    currentLvl = 0;

    // checking mode
    if (isLevelMode) {
      isLevelMode = false;
      pulsePin(buzzerPin, 500);
    } else {

      // signal for player 
      for (int i = 0; i < 3; i++) {
        digitalWrite(buzzerPin, HIGH);
        displayDigit(0);
        delay(400);
        displayDigit(10);
        digitalWrite(buzzerPin, LOW);
        delay(400);
      }
      isLevelMode = true;
    }
  }
}

// handle the menu logic
void menu() {
  int y = analogRead(joyY);

  // checking player click the button to change mode
  switchLevel();

  // checking the joystick
  if (!yMoved) {
    if (y > 600 || y < 400) {
      chooseLevel(y);
      yMoved = true;
    }
  } else {
    if (y >= 450 && y <= 570) {
      yMoved = false;
    }
  }

  delay(50);
}

// checking the level length
bool checkLevellength() {
    if (currentLvl >= levels[lvlCounter - 1].length) {
      isLevelMode = false;
      currentLvl = 0;
      displayDigit(currentLvl);
    return true;
  }

  return false;
}

// checking player move
bool checkIsPlayerMove(bool move, int displayingSegment) {
  int x = analogRead(joyX);
  int y = analogRead(joyY);

  // move
  if (x > 600 || x < 400 || y > 600 || y < 400) {
    isDirectionCorrect = handleJoystick(x, y, displayingSegment);
    move = true;

    return true;
  }

  return false;
}

// handle the level logic
void level() {
  // listening the level length 
  if (checkLevellength()) {
    return;
  }
  currentLvl++;

  // getting the random segment
  int displayingSegment = drawSegment(4);

  // reset the variable 
  bool move = false;

  unsigned long lastSave = millis();

  // listening the level time
  while ((millis() - lastSave) < levels[lvlCounter - 1].speed) {
    // checking player click the button to change mode
    switchLevel();

    if (!isLevelMode) { // continue checking mode
      return;
    }

    // checking is player move
    if (checkIsPlayerMove(move, displayingSegment)) {
      break;
    }

    delay(50);
  }

  checkScore(isDirectionCorrect);

  // reset segments
  displayDigit(BLANK);
  delay(200);

  isDirectionCorrect = false;

  int y = analogRead(joyY);

  // idk why it was creat
  if (y > 600 || y < 400) {
    chooseLevel(y);
  }
}

void loop() {
  if (!isLevelMode) {
    menu();
  } else {
    level();
  }
}